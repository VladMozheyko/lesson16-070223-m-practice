import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {

    /*
    План занятия
    1) Знакомство с потоками ввода-вывода
    2) Знакомство с сокетами
    3) Обзор клиент-серверных приложений
     */

    /*
    Теория
    Компьютеры могут обмениваться данными при помощи сетей. Для обмена данными у каждого компьютера есть адрес в сети.
    У компьютера есть MAC_адрес - личный адрес компьютера, ip-адрес - адрес компьютера в сети, он может динамически меняться.
    Существуют протоколы - правила обмена данными для компьютерных сетей: http, udp, socket
    Компьютерная сеть  - объединение нескольких компьютеров.

    Сокет - условно можно представить в виде квартиры в доме, где дом является ip-адресов, когда мы говорим о подключении к
    такому-то компьютеру, кроме адреса, необходимо указать и сокет, т.е. открытый пункт связи между устройствами.

    Для работы с сокетами в Java существуют классы: Socket и SeverSocket

    SeverSocket - класс для приема подключений, он принимает адрес сокета, на котором будет ожидать подключения клиента

    Socket - класс для работы с сокетами, т.е. оправка и чтение сообщений

    OutputStreamWriter  - класс для записи сообщений

    BufferedReader  - класс для чтения сообщений

     */

    /*
    Заметки
    В русском языке есть два термина "поток"(неккоректный первод с английского):
    1) Поток исполнения(Thread) - поток относится к параллельному выполнянению инструкций программы
    2) Поток ввода или вывода(Stream) - канал обмена данными: ввода данных в программу или их вывода из программы

    Пока мы работаем только в локальной сети - т.е. можем обращаться к серверу только, если подключены к одному источнику
    интернета, чтобы сделать связь глобальной, нужно выполнить операцию "проброски" порта

    Исключения(Exception) - способ обработать не предвиденные ситуации

    В Intelij Idea есть возможность собрать конфигурацию - т.е. в рамках одного проекта задать программу, которая будет исполняться
    из любой точки. Следовательно в границах одного проекта можно создать несколько программ независимых друг от друга

    finalize() - метод класса Object, который вызывается при удалении объекта. Помечен как deprecated, потому что многие
    программисты путают его с деструктором(в Java их нет), т.е. думают, что могут вызвать этот метод самостоятельно, на
    самом деле этот метод будет вызыван JVM, когда она посчитаем это целесообразным, поэтому спрогнозировать его вызов
    невозможно и сам метод стоит использовать аккуратно


     */

    public static void main(String[] args) throws IOException {   // throws IOException - обрабатывает возможные исключения
	/*
	Задача
	Создать сервер, который будет в бесконечном цикле принимать сообщения от клиента и давать ему ответ
	 */

        /*
        Пример обработки исключения

        try {
            int[] arr = new int[10];
            System.out.println(arr[11]);
        }
        catch (Exception ex){
            System.out.println("Возникла ошибка, но жизнь продолжается");
        }
        System.out.println("Привет");

         */
        ServerSocket serverSocket = new ServerSocket(8015);    // Прослушивание сокета на порту 8015
        int count = 0;                                         // Счетчик клиентов
        System.out.println("Server running...");
        while (true){                                          // Прослушиваем подключения к серверу
            Socket clientSocket = serverSocket.accept();       //Обращаемся к серверу, чтобы принять клиента. Создаем сокет, для общения клиента и сервера
            System.out.println("Клиент номер: " + count++);    // Выводим на консоль номер клиента
            OutputStreamWriter writer = new OutputStreamWriter(clientSocket.getOutputStream()); // Создаем поток записи сообщения для клиентов, в конструкторе обращаемся к сокету, чтобы отправить в него сообщение
            BufferedReader bufReader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); // Создаем поток для чтения сообщений клиента, чтобы получить от него запрос
            String request = bufReader.readLine();   // Получаем запрос от потока чтения
            //  Thread.sleep(5000);  // Ждем 5 секунд
            String response = "Длина вашего сообщения: " + request.length() + "\n"; // Формируем ответ от сервера
            writer.write(response);    // Отправляю ответ клиенту
            writer.flush();            // Команда на полную отправку имеющихся строк
            writer.close();            // Закрываем потоки записи и чтения
            bufReader.close();
            clientSocket.close();     // Закрываем соединение с клиентом
        }
    }

    /*
    ДЗ
    Сделать клиент-серверную игру "Угадай число". На сервере будет загаданно число, а клиент будет пытаться его отгадать.
    Реализовать счетчик попыток и выводить его клиенту. В случае угадывания. Завершить игру. У меня на github игра реализрвана
    по ссылке: https://github.com/VladMozheyko/SocketGame
     */
}
